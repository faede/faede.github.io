<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Learn C++ From Last | zyy</title><meta name="keywords" content="c++"><meta name="author" content="zyy"><meta name="copyright" content="zyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="mutablelambda-declarator that removes const qualification from parameters captured by copy (since C++11) decltype推导规则如下:  If the argument is an unparenthesized id-expression or an unparenthesized clas">
<meta property="og:type" content="article">
<meta property="og:title" content="Learn C++ From Last">
<meta property="og:url" content="http://example.com/2020/12/25/Learn-C-From-Last/index.html">
<meta property="og:site_name" content="zyy">
<meta property="og:description" content="mutablelambda-declarator that removes const qualification from parameters captured by copy (since C++11) decltype推导规则如下:  If the argument is an unparenthesized id-expression or an unparenthesized clas">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/faede/faede.github.io/blob/master/images/page1.png">
<meta property="article:published_time" content="2020-12-24T18:30:28.000Z">
<meta property="article:modified_time" content="2020-12-24T18:30:59.741Z">
<meta property="article:author" content="zyy">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/faede/faede.github.io/blob/master/images/page1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/12/25/Learn-C-From-Last/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-25 02:30:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://github.com/faede/faede.github.io/blob/master/images/page1.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zyy</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Learn C++ From Last</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-24T18:30:28.000Z" title="Created 2020-12-25 02:30:28">2020-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-12-24T18:30:59.741Z" title="Updated 2020-12-25 02:30:59">2020-12-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda"><em>lambda-declarator</em> </a>that removes <code>const</code> qualification from parameters captured by copy (since C++11)</p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>推导规则如下:</p>
<ol>
<li>If the argument is an unparenthesized <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/identifiers">id-expression</a> or an unparenthesized <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_member_access">class member access</a> expression, then decltype yields the type of the <em>entity</em> named by this expression. If there is no such entity, or if the argument names a set of overloaded functions, the program is ill-formed.</li>
</ol>
<table>
<thead>
<tr>
<th>If the argument is an unparenthesized <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/identifiers">id-expression</a> naming a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/structured_binding">structured binding</a>, then decltype yields the <em>referenced type</em> (described in the specification of the structured binding declaration).</th>
<th>(since C++17)</th>
</tr>
</thead>
<tbody><tr>
<td>If the argument is an unparenthesized <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/identifiers">id-expression</a> naming a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter">non-type template parameter</a>, then decltype yields the type of the template parameter (after performing any necessary type deduction if the template parameter is declared with a placeholder type).</td>
<td>(since C++20)</td>
</tr>
</tbody></table>
<ol start="2">
<li>If the argument is any other expression of type <code>T</code>, and</li>
</ol>
<p>​    a) if the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">value category</a> of <em>expression</em> is <em>xvalue</em>, then decltype yields <code>T&amp;&amp;</code>;</p>
<p>​    b) if the value category of <em>expression</em> is <em>lvalue</em>, then decltype yields <code>T&amp;</code>;</p>
<p>​    c) if the value category of <em>expression</em> is <em>prvalue</em>, then decltype yields <code>T</code>.</p>
<table>
<thead>
<tr>
<th>If <em>expression</em> is a function call which returns a prvalue of class type or is a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_other">comma expression</a> whose right operand is such a function call, a temporary object is not introduced for that prvalue.</th>
<th>(until C++17)</th>
</tr>
</thead>
<tbody><tr>
<td>If <em>expression</em> is a prvalue other than a (possibly parenthesized) <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/consteval">immediate invocation</a> (since C++20), a temporary object is not <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/implicit_cast#Temporary_materialization">materialized</a> from that prvalue: such prvalue has no result object.</td>
<td>(since C++17)</td>
</tr>
</tbody></table>
<p>The type need not be <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/incomplete_type">complete</a> or have an available <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>, and can be <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/abstract_class">abstract</a>. This rule doesn’t apply to sub-expressions: in decltype(f(g())), g() must have a complete type, but f() need not.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="keyword">double</span> x; &#125;;</span><br><span class="line"><span class="keyword">const</span> A* a;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x) y;       <span class="comment">// type of y is double (declared type)</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)) z = y; <span class="comment">// type of z is const double&amp; (lvalue expression)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u) // return type depends on template parameters</span><br><span class="line">                                      <span class="comment">// return type can be deduced since C++14</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(i) j = i * <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">decltype</span>(f) g = f; <span class="comment">// the type of a lambda function is unique and unnamed</span></span><br><span class="line">    i = f(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    j = g(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何禁用vs安全检查"><a href="#如何禁用vs安全检查" class="headerlink" title="如何禁用vs安全检查"></a>如何禁用vs安全检查</h3><p>#define _CRT_SECURE_NO_WARNINGS</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>The <code>constexpr</code> specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constant_expression">constant expressions</a> are allowed (provided that appropriate function arguments are given). A constexpr specifier used in an object declaration or non-static member function (until C++14) implies const. A constexpr specifier used in a function or <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/static">static</a> member variable (since C++17) declaration implies inline. If any declaration of a function or function template has a <code>constexpr</code> specifier, then every declaration must contain that specifier.</p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><h3 id="Memory-Layout-of-C-Programs"><a href="#Memory-Layout-of-C-Programs" class="headerlink" title="Memory Layout of C Programs"></a>Memory Layout of C Programs</h3><p>A typical memory representation of C program consists of following sections.</p>
<ol>
<li>Text segment</li>
<li>Initialized data segment</li>
<li>Uninitialized data segment</li>
<li>Stack</li>
<li>Heap</li>
</ol>
<p>![memoryLayoutC](/Users/zyy/Documents/GitHub/Daily/C++ learn from the past/memoryLayoutC.jpg)</p>
<p> <strong>1. Text Segment:</strong></p>
<p>A text segment , also known as a code segment or simply as text, is one of the sections of a program in an object file or in memory, which contains executable instructions.</p>
<p>As a memory region, a text segment may be placed below the heap or stack in order to <strong>prevent heaps and stack overflows from overwriting it</strong>.</p>
<p>Usually, the text segment is sharable so that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. Also, the text segment is <strong>often read-only</strong>, to prevent a program from accidentally modifying its instructions.</p>
<p><strong>2. Initialized Data Segment:</strong></p>
<p>Initialized data segment, usually called simply the Data Segment. A data segment is a portion of virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer.</p>
<p>Note that, data segment is <strong>not read-only</strong>, since the values of the variables can be altered at run time.</p>
<p>This segment can be further classified into <strong>initialized read-only area</strong> and <strong>initialized read-write area</strong>.</p>
<p>For instance the <strong>global</strong> string defined by <strong>char s[] = “hello world”</strong> in C and a C statement <strong>like int debug=1</strong> outside the main (i.e. global) would be stored <strong>in initialized read-write area</strong>. And a <strong>global</strong> C statement like *<em>const char</em> string = “hello world”** makes the <strong>string literal “hello world” to be stored in initialized read-only area</strong> and the <strong>character pointer variable string in initialized read-write area</strong>.</p>
<p>Ex: static int i = 10 will be stored in data segment and global int i = 10 will also be stored in data segment</p>
<p><strong>3. Uninitialized Data Segment:</strong></p>
<p>Uninitialized data segment, often called the <strong>“bss” segment</strong>, named after an ancient assembler operator that stood for “block started by symbol.” Data in this segment is <strong>initialized by the kernel to arithmetic 0 before the program starts executing</strong></p>
<p>uninitialized data starts at the end of the data segment and contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code.</p>
<p>For instance a variable declared <strong>static int i</strong>; would be contained in the BSS segment.</p>
<p>For instance a global variable declared <strong>int j</strong>; would be contained in the BSS segment.</p>
<p><strong>4. Stack:</strong></p>
<p>The stack area traditionally <strong>adjoined the heap area and grew the opposite direction</strong>; when the stack <strong>pointer met the</strong> heap pointer, <strong>free memory was exhausted</strong>. (With modern large address spaces and virtual memory techniques they may be placed almost anywhere, but they still typically grow opposite directions.)</p>
<p>The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory. On the <strong>standard PC x86 computer architecture</strong> it <strong>grows toward address zero</strong>; on some other architectures it grows the opposite direction. A <strong>“stack pointer”</strong> register tracks the top of the stack; it is <strong>adjusted each time a value is “pushed” **onto the stack. The **set of values pushed</strong> for one function call is termed <strong>a “stack frame”</strong>; A stack frame consists at minimum of a return address.</p>
<p>Stack, where <strong>automatic variables</strong> are stored, along with information that is saved each time a function is called. Each time a function is called, the address of where to return to and certain information about the caller’s environment, such as some of the machine registers, are saved on the stack.<strong>The newly called function then allocates room on the stack for its automatic and temporary variables</strong>. This is how recursive functions in C can work. Each time a recursive function calls itself, a new stack frame is used, so one set of variables doesn’t interfere with the variables from another instance of the function.</p>
<p><strong>5. Heap:</strong></p>
<p>Heap is the segment where <strong>dynamic memory allocation usually takes place</strong>.</p>
<p>The heap area begins at the <strong>end of the BSS segment</strong> and <strong>grows to larger addresses</strong> from there.The Heap area is <strong>managed by malloc, realloc, and free</strong>, which may use the brk and sbrk system calls to adjust its size (note that the use of brk/sbrk and a single “heap area” is not required to fulfill the contract of malloc/realloc/free; they <strong>may</strong> also be implemented using <strong>mmap</strong> to <strong>reserve potentially non-contiguous regions of virtual memory into the process’ virtual address space</strong>). <strong>The Heap area is shared by all shared libraries and dynamically loaded modules in a process</strong>.</p>
<p>Examples.</p>
<p>The size(1) command reports the sizes (in bytes) of the text, data, and bss segments. ( for more details please refer man page of size(1) )</p>
<ol>
<li>Check the following simple C program</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> gcc memory-layout.c -o memory-layout</span></span><br><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> size memory-layout</span></span><br><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line">960        248         8          1216       4c0    memory-layout</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Let us add one global variable in program, now check the size of bss (highlighted in red color).</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> gcc memory-layout.c -o memory-layout</span></span><br><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> size memory-layout</span></span><br><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line">960        248         12         1220       4c4    memory-layout</span><br><span class="line"><span class="meta">#</span><span class="bash">last</span></span><br><span class="line">960        248         8          1216       4c0    memory-layout</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Let us add one static variable which is also stored in bss.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">/* Uninitialized static variable stored in bss */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> gcc memory-layout.c -o memory-layout</span></span><br><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> size memory-layout</span></span><br><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line">960        248         16         1224       4c8    memory-layout</span><br><span class="line"><span class="meta">#</span><span class="bash">last</span></span><br><span class="line">960        248         12         1220       4c4    memory-layout</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Let us initialize the static variable which will then be stored in Data Segment (DS)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>; <span class="comment">/* Initialized static variable stored in DS*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> gcc memory-layout.c -o memory-layout</span></span><br><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> size memory-layout</span></span><br><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line">960        252         12         1224       4c8    memory-layout</span><br><span class="line"><span class="meta">#</span><span class="bash">last</span></span><br><span class="line">960        248         12         1220       4c4    memory-layout</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Let us initialize the global variable which will then be stored in Data Segment (DS)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> global = <span class="number">10</span>; <span class="comment">/* initialized global variable stored in DS*/</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>; <span class="comment">/* Initialized static variable stored in DS*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> gcc memory-layout.c -o memory-layout</span></span><br><span class="line"><span class="meta">[narendra@CentOS]$</span><span class="bash"> size memory-layout</span></span><br><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line">960        256         8          1224       4c8    memory-layout</span><br><span class="line"><span class="meta">#</span><span class="bash">last</span></span><br><span class="line">960        248         8          1216       4c0    memory-layout</span><br></pre></td></tr></table></figure>
<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>c = &gt; c++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">s = a;</span><br></pre></td></tr></table></figure>


<p>c++ =&gt; c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = str.c_str(); <span class="comment">// const不能省略</span></span><br><span class="line"><span class="comment">// 进一步？</span></span><br><span class="line"><span class="built_in">string</span> s2 = s;</span><br></pre></td></tr></table></figure>


<p>输出到字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buf;</span><br></pre></td></tr></table></figure>


<h3 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge"></a>inplace_merge</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(Iter first, Iter last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Iter middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(first, middle);</span><br><span class="line">        merge_sort(middle, last);</span><br><span class="line">        <span class="built_in">std</span>::inplace_merge(first, middle, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">8</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    merge_sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n : v) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="C语言中的强符号与弱符号"><a href="#C语言中的强符号与弱符号" class="headerlink" title="C语言中的强符号与弱符号"></a>C语言中的强符号与弱符号</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/astrotycoon/article/details/8008629">https://blog.csdn.net/astrotycoon/article/details/8008629</a></p>
<h3 id="i"><a href="#i" class="headerlink" title="%i"></a>%i</h3><p>scanf读入数字 将0开头解析为8进制,0x开头16进制</p>
<h3 id="C语言数组下标可以为负数"><a href="#C语言数组下标可以为负数" class="headerlink" title="C语言数组下标可以为负数"></a>C语言数组下标可以为负数</h3><p>个人觉得[]被实现为*(array+i)的话那自然要和i为负数的时候统一.</p>
<p>并且似乎将指针索引隐式转换成正数并不能带来什么好处, 访问一个很大的索引未必比访问一个绝对值小的负数来的更加安全(虽然可能都是危险行为)</p>
<h3 id="探索C-析构函数"><a href="#探索C-析构函数" class="headerlink" title="探索C++析构函数"></a>探索C++析构函数</h3><p>深度探索c++对象模型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果class没有定义destructor,那么只有在class内含有member object(异或class自己的bass class)拥有destructor 的情况下,编译器才会合成一个出来.否则,destructor被视为不需要,也就不需被合成(当然更不需要被调用).</span><br></pre></td></tr></table></figure>
<p>如果我们定义了其它构造函数,但是没有定义默认构造函数,是不允许的</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ~A(<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>如下正确:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ~A(<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">  ~A()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>在函数体中我们可以显示的调用析构函数,但是显示调用析构函数并不会释放对象的空间,(其实我们不应该显示调用析构函数). (当然vs下可能不同 合情(一贯风格)推理vs做了骚操作)</p>
<p>并且我们可以通过添加<code>&#123;&#125;</code>来改变对象的作用域,并且离开<code>&#123;&#125;</code>的作用域的时候会调用析构函数,并且如果离开的是我们定义的函数那么对象会被销毁.其他对象main函数前</p>
<p>总的来说编译器会在对象离开作用域前添加对析构函数的调用.</p>
<p>进一步举证如下:</p>
<p>曾经想法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于析构函数来说真正的对象销毁工作应该在对象离开对象的作用域时,但是最终调用的对象析构函数应该是发生在main函数返回(return )前的,所以我推测编译器在最后为代码添加了析构函数的调用,</span><br><span class="line"></span><br><span class="line">当然也有可能最终函数的执行会交由外部函数处理,但我觉得并不合理,内外部函数存放的位置不同,如果没有其它未知操作的话,外部执行最后的析构函数会导致相同的代码在不同的段存放两次,这感觉并不是很合理,除非两段会共用,不过具体情况也就不得而知了.</span><br><span class="line"></span><br><span class="line">综上所述,就目前来讲,对象的析构函数还是不要显示调用来的好(当然除了数组需要delete的情况).</span><br></pre></td></tr></table></figure>
<p>实践:</p>
<p>确实是编译器添加了析构函数的调用</p>
<p>我用了在线汇编</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">A::~A() [base object destructor]:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     </span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        lea     rax, [rbp-8]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    A::~A() [complete object destructor]</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">__static_initialization_and_destruction_0(int, int):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     DWORD PTR [rbp-4], edi</span><br><span class="line">        mov     DWORD PTR [rbp-8], esi</span><br><span class="line">        cmp     DWORD PTR [rbp-4], 1</span><br><span class="line">        jne     .L6</span><br><span class="line">        cmp     DWORD PTR [rbp-8], 65535</span><br><span class="line">        jne     .L6</span><br><span class="line">        mov     edi, OFFSET FLAT:_ZStL8__ioinit</span><br><span class="line">        call    std::ios_base::Init::Init() [complete object constructor]</span><br><span class="line">        mov     edx, OFFSET FLAT:__dso_handle</span><br><span class="line">        mov     esi, OFFSET FLAT:_ZStL8__ioinit</span><br><span class="line">        mov     edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev</span><br><span class="line">        call    __cxa_atexit</span><br><span class="line">.L6:</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br><span class="line">_GLOBAL__sub_I_main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     esi, 65535</span><br><span class="line">        mov     edi, 1</span><br><span class="line">        call    __static_initialization_and_destruction_0(int, int)</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>clang(只截取一部分):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line">## %bb.0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	leaq	-8(%rbp), %rdi</span><br><span class="line">	callq	__ZN1AD1Ev</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br><span class="line">	.globl	__ZN1AD1Ev              ## -- Begin function _ZN1AD1Ev</span><br><span class="line">	.weak_def_can_be_hidden	__ZN1AD1Ev</span><br><span class="line">	.p2align	4, 0x90</span><br><span class="line">__ZN1AD1Ev:                             ## @_ZN1AD1Ev</span><br><span class="line">	.cfi_startproc</span><br><span class="line">## %bb.0:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movq	%rdi, -8(%rbp)</span><br><span class="line">	movq	-8(%rbp), %rdi</span><br><span class="line">	callq	__ZN1AD2Ev</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br><span class="line">	.globl	__ZN1AD2Ev              ## -- Begin function _ZN1AD2Ev</span><br><span class="line">	.weak_def_can_be_hidden	__ZN1AD2Ev</span><br><span class="line">	.p2align	4, 0x90</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">    A a2;</span><br><span class="line">    &#123;</span><br><span class="line">        A b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    c += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 32</span><br><span class="line">        lea     rax, [rbp-28]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    A::~A() [complete object destructor]</span><br><span class="line">        mov     DWORD PTR [rbp-4], 1</span><br><span class="line">        add     DWORD PTR [rbp-4], 2</span><br><span class="line">        lea     rax, [rbp-20]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    A::~A() [complete object destructor]</span><br><span class="line">        lea     rax, [rbp-12]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    A::~A() [complete object destructor]</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">void</span> (* p1) () = foo;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">()</span></span>;</span><br><span class="line">    fp p2 = foo;</span><br><span class="line">    p1();</span><br><span class="line">    <span class="keyword">int</span> (*a1)(<span class="keyword">int</span>,<span class="keyword">int</span>) = add;</span><br><span class="line">    c = a1(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*af)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> </span>;</span><br><span class="line">    af a2 = add;</span><br><span class="line">    c = a2(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的成员变量有三个位置进行初始化：</p>
<p>声明时初始化:</p>
<p>初始化列表初始化（ 成员变量初始化的顺序是按照在那种定义的顺序）</p>
<p>以下三种情况下必须使用初始化成员列表<br>一、需要初始化的数据成员是对象，且该对象不能默认构造。(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。<br>二、需要初始化const修饰的类成员；（C++11后，声明时初始化也可以）<br>三、需要初始化引用成员数据；</p>
<p> 对于一补充:</p>
<p>c++ primer P258</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果没有构造函数的初始化列表中显式地初始化成员,</span><br><span class="line">则该成员将在构造函数体之前执行默认初始化.</span><br></pre></td></tr></table></figure>
<p>所以对于类成员,我们需要定义默认初始化,或者在初始化列表中初始化</p>
<p>变量初始化顺序:</p>
<p>c++ primer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">不过稍让人意外的是,构造函数初始值列表只用于初始化成员的值,而不限定初始化执行的顺序.</span><br><span class="line">成员的初始化顺序与它们在类定义中的出现顺序一致:第一个成员先被初始化,然后第二个,以此类推. 构造函数初始化列表中初始化值的前后位置关系不会影响实际的初始化顺序.</span><br><span class="line">一般情况下初始化的顺序没什么要求,如果如果一个成员使用另一个成员来初始化的,那么这两个成语啊你的初始化顺序就很关键了.</span><br><span class="line">  举个例子,考虑下面这个类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//未定义的,i在j之前初始化</span></span><br><span class="line">  X(<span class="keyword">int</span> val):j(val),i(j)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 补充:  X(int val):i(val),j(i)&#123;&#125;   OK</span></span><br><span class="line">&#125;;</span><br><span class="line">有些编译器具备一项比较友好的功能,即当构造函数和初始化列表中的数据成员顺序与这些成员声明的顺序不符时会生成一条警告信息.</span><br></pre></td></tr></table></figure>


<p>构造函数内赋值初始化成员变量:</p>
<p>对于内置类型（char，int……指针等）:</p>
<blockquote>
<p>基本上是没有区别的，效率上也不存在多大差异</p>
</blockquote>
<p>对于自定义类对象的成员初始化</p>
<ul>
<li>初始化列表是直接调用拷贝函数构造；</li>
<li>构造函数内赋值是先调用默认构造函数构造（当然，你得保证你定义的类有无参构造函数），在调用重载赋值函数赋值<br>所以使用初始化列表效率高很多。<strong>能使用初始化列表的时候尽量使用初始化列表</strong></li>
</ul>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程,或者说把它自己的一些(或者全部)指责委托给了其他函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">  <span class="comment">// 非委托构造函数</span></span><br><span class="line">  Sales_data(<span class="built_in">string</span> s,<span class="keyword">int</span> a):name(s),num(a)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 委托构造函数</span></span><br><span class="line">  Sales_data():Sales_data(<span class="string">&quot;&quot;</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针与数组并不相同"><a href="#指针与数组并不相同" class="headerlink" title="指针与数组并不相同"></a>指针与数组并不相同</h3><p>《C专家编程》</p>
<p>对于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">9</span>]  = <span class="string">&quot;abcdefg&quot;</span>;       c = a[i];</span><br><span class="line">编译器符号表具有一个地址<span class="number">9980</span></span><br><span class="line">  运行时步骤<span class="number">1</span>:取i的值,并将它与<span class="number">9980</span>相加</span><br><span class="line">  运行时步骤<span class="number">2</span>:取地址(<span class="number">9980</span>+i)的内容</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;       c = *[p];</span><br><span class="line">编译器符号表具有一个符号p,它的地址为<span class="number">4624</span></span><br><span class="line">  运行时步骤1:取地址4624的值,就是 &#x27;5081&#x27;</span><br><span class="line">  运行时步骤<span class="number">2</span>:取地址<span class="number">5081</span>的内容</span><br></pre></td></tr></table></figure>
<p>多了一次额外的提取</p>
<p>当你定义为指针,但以数组方式引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p  = <span class="string">&quot;abcdefg&quot;</span>;       c = p[i];</span><br><span class="line">编译器符号表具有一个p,地址为<span class="number">4624</span></span><br><span class="line">  运行时步骤1:取地址4624的内容,就是 &#x27;5081&#x27;</span><br><span class="line">  运行时步骤<span class="number">2</span>:取得i的值,并将它与<span class="number">5081</span>相加.</span><br><span class="line">  运行时步骤<span class="number">3</span>:取地址(<span class="number">5081</span>+i)的内容</span><br></pre></td></tr></table></figure>




<h3 id="什么时候数组和指针是一样的"><a href="#什么时候数组和指针是一样的" class="headerlink" title="什么时候数组和指针是一样的"></a>什么时候数组和指针是一样的</h3><p>The C Programming Language  ed. 2 ,P99</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">as format parameters in function definition</span><br><span class="line">  <span class="keyword">char</span> s[];</span><br><span class="line"><span class="keyword">and</span> </span><br><span class="line">  <span class="keyword">char</span>* s;</span><br><span class="line">are equivalent;</span><br></pre></td></tr></table></figure>
<p>1.表达式中的数组名(与声明不同)被编译器当作指向该数组第一个元素的指针</p>
<p>2.下标总是与指针的偏移量相同</p>
<p>3.在函数参数的生命中,数组名被编译器当作指向该数组第一个元素的指针.</p>
<h3 id="可以返回一个数组首地址吗"><a href="#可以返回一个数组首地址吗" class="headerlink" title="可以返回一个数组首地址吗?"></a>可以返回一个数组首地址吗?</h3><p>局部数组不可以:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp[arrlen]; </span><br></pre></td></tr></table></figure>
<p>动态数组可以:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[arrlen];</span><br></pre></td></tr></table></figure>
<p>这自然是因为两个数组中变量存储的位置不同</p>
<h3 id="void-main-与-main-void"><a href="#void-main-与-main-void" class="headerlink" title="void main 与 main(void)"></a>void main 与 main(void)</h3><p>第二个答案:</p>
<p><code>https://www.zhihu.com/question/358133724</code></p>
<p>![voidmain](/Users/zyy/Documents/GitHub/Daily/C++ learn from the past/voidmain.jpg)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns:  a pointer to void if successful, or NULL if not.</span><br></pre></td></tr></table></figure>


<p>void main似乎是一个遗留问题,</p>
<p>在之后void main应该是个ub ,编译器不会执行类型检查,汇编正常执行</p>
<p>有的编译器或许会添加上return 0;</p>
<p>而对于main(void):</p>
<p>取自:<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/358133724">https://www.zhihu.com/question/358133724</a></p>
<p>C语言是调用者清栈，所以main函数不写参数也可以，比如 main(void)，不会运行出错，只是函数里拿不到命令行参数，但是压栈的参数还是会被正确处理</p>
<p>但如今实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = main (argc, argv, __environ MAIN_AUXVEC_PARAM); </span><br><span class="line"><span class="built_in">exit</span>(result);</span><br></pre></td></tr></table></figure>
<p> 如今应该都会补上return 0 或者直接报错了.</p>
<h3 id="NULL-and-nullptr"><a href="#NULL-and-nullptr" class="headerlink" title="NULL and nullptr"></a>NULL and nullptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__need_NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> !defined(__MINGW32__) &amp;&amp; !defined(_MSC_VER)</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> NULL __null</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_MSC_EXTENSIONS) &amp;&amp; defined(_NATIVE_NULLPTR_SUPPORTED)</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123; <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>; &#125;</span><br><span class="line"><span class="keyword">using</span> ::<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __need_NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__need_NULL) */</span></span></span><br></pre></td></tr></table></figure>
<p>Test code:</p>
<p>clang :</p>
<p>注意下面的 NULL 其实被上方define成了 __null，在MINGW和MSC中其实被定义成了0，在后两者中是不会造成歧义的，但是前面不行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> * a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test 1 :&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test 2 : &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="literal">nullptr</span>); <span class="comment">// &quot;test 1 :&quot;</span></span><br><span class="line">    func(<span class="number">0</span>);    <span class="comment">// &quot;test 2 : &quot;</span></span><br><span class="line">    <span class="comment">//func(NULL); error: ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下部分基本可以看：<code>https://blog.csdn.net/qq_18108083/article/details/84346655?utm_source=app</code> 了。</p>
<p>以下部分源自博客：</p>
<p><strong>一、C程序中的NULL</strong></p>
<p>在C语言中，NULL通常被定义为：*<em>#define NULL ((void \</em>)0)**</p>
<p>所以说NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  *pi = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>二、C++程序中的NUL</strong></p>
<p>但是问题来了，以上代码如果使用C++编译器来编译则是会出错的，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可见，在C++中，NULL实际上是0.因为C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了结果空指针的表示问题，C++引入了0来表示空指针，这样就有了上述代码中的NULL宏定义。</p>
<p><strong>其他：在没有C++ 11的nullptr的时候，我们怎么解决避免这个问题呢？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">class</span> <span class="title">nullptr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>//系统把NULL定位为int，把nullptr定位为void*</p>
<h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p><code>https://docs.microsoft.com/zh-cn/windows/win32/SecBP/avoiding-buffer-overruns</code></p>
<p>Buffer overruns can occur in a variety of ways. The following list provides a brief introduction to a few types of buffer overrun situations and offers some ideas and resources to help you avoid creating new risks and mitigate existing ones:</p>
<ul>
<li><p>Static buffer overruns</p>
<p>A static buffer overrun occurs when a buffer, which has been declared on the stack, is written to with more data than it was allocated to hold. The less apparent versions of this error occur when unverified user input data is copied directly to a static variable, causing potential stack corruption.</p>
</li>
<li><p>Heap overruns</p>
<p>Heap overruns, like static buffer overruns, can lead to memory and stack corruption. Because heap overruns occur in heap memory rather than on the stack, some people consider them to be less able to cause serious problems; nevertheless, heap overruns require real programming care and are just as able to allow system risks as static buffer overruns.</p>
</li>
<li><p>Array indexing errors</p>
<p>Array indexing errors also are a source of memory overruns. Careful bounds checking and index management will help prevent this type of memory overrun.</p>
</li>
</ul>
<p>Preventing buffer overruns is primarily about writing good code. Always validate all your inputs and fail gracefully when necessary. For more information about writing secure code, see the following resources:</p>
<ul>
<li>Maguire, Steve [1993], <em>Writing Solid Code</em>, ISBN 1-55615-551-4, Microsoft Press, Redmond, Washington.</li>
<li>Howard, Michael and LeBlanc, David [2003], <em>Writing Secure Code</em>, 2d ed., ISBN 0-7356-1722-8, Microsoft Press, Redmond, Washington.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zyy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/12/25/Learn-C-From-Last/">http://example.com/2020/12/25/Learn-C-From-Last/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://github.com/faede/faede.github.io/blob/master/images/page1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/12/25/hello-world/"><img class="next-cover" src="https://github.com/faede/faede.github.io/blob/master/images/page1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">zyy</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/faede" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutable"><span class="toc-number">1.</span> <span class="toc-text">mutable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">2.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8vs%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">3.</span> <span class="toc-text">如何禁用vs安全检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">5.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda"><span class="toc-number">6.</span> <span class="toc-text">lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Layout-of-C-Programs"><span class="toc-number">7.</span> <span class="toc-text">Memory Layout of C Programs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text">字符串转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inplace-merge"><span class="toc-number">9.</span> <span class="toc-text">inplace_merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E7%AC%A6%E5%8F%B7"><span class="toc-number">10.</span> <span class="toc-text">C语言中的强符号与弱符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i"><span class="toc-number">11.</span> <span class="toc-text">%i</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%8F%AF%E4%BB%A5%E4%B8%BA%E8%B4%9F%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">C语言数组下标可以为负数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A2%E7%B4%A2C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">探索C++析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">14.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">15.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E5%B9%B6%E4%B8%8D%E7%9B%B8%E5%90%8C"><span class="toc-number">17.</span> <span class="toc-text">指针与数组并不相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84"><span class="toc-number">18.</span> <span class="toc-text">什么时候数组和指针是一样的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A6%96%E5%9C%B0%E5%9D%80%E5%90%97"><span class="toc-number">19.</span> <span class="toc-text">可以返回一个数组首地址吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-main-%E4%B8%8E-main-void"><span class="toc-number">20.</span> <span class="toc-text">void main 与 main(void)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NULL-and-nullptr"><span class="toc-number">21.</span> <span class="toc-text">NULL and nullptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">22.</span> <span class="toc-text">缓冲区溢出</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/25/Learn-C-From-Last/" title="Learn C++ From Last"><img src="https://github.com/faede/faede.github.io/blob/master/images/page1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learn C++ From Last"/></a><div class="content"><a class="title" href="/2020/12/25/Learn-C-From-Last/" title="Learn C++ From Last">Learn C++ From Last</a><time datetime="2020-12-24T18:30:28.000Z" title="Created 2020-12-25 02:30:28">2020-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/25/hello-world/" title="Hello World"><img src="https://github.com/faede/faede.github.io/blob/master/images/page1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2020/12/25/hello-world/" title="Hello World">Hello World</a><time datetime="2020-12-24T16:36:21.932Z" title="Created 2020-12-25 00:36:21">2020-12-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By zyy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">=.=</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>